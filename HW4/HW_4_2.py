# 2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»
# Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов.
# Результаты анализа сохранить в виде комментариев в файле с кодом.

from time import time


def is_prime(n):  # Функция определения простого числа
    if n % 2 == 0:  # Проверяем деление на 2 без остатка для исключения четных чисел
        return n == 2
    d = 3
    while d * d <= n and n % d != 0:  # Проверяем что делитель не не превосходит квадратный корнь из числа и остаток !=0
        d += 2  # Увеличиваем значение d
    return d * d > n  # Заканчиваем  и возвращаем True или False


def no_eratosthenes(user_number):  # Поиск простого числа без алгоритма «Решето Эратосфена»
    k = 0  # Задаем число по умолчанию
    i = 1  # Задаем индекс по умолчанию
    # user_number = int(input('Введите индекс по счету простого числа: '))  # Ввод индекса числа
    while i <= int(user_number):  # Начинаем цикл пока счетчик не сравняется с введенным числом
        if is_prime(k) is True:  # Проверяем является число простым через функцию is_prime. Если да то прибавляем индекс
            i += 1  # Прибавляем индекс
        k += 1  # Увеличиваем число на единицу
    return i - 1, is_prime(k - 1), k - 1  # Выводим последний результат расчета


def sieve_eratosthenes(n):  # Поиск простого числа по алгоритму Эратосфена
    # Как перевести на индекс - не разобрался, сделал костыльый алгоритм.
    # n  = int(input("Введите индекс по счету простого числа "))
    n1 = n
    n = n * 50
    a = [0] * n  # создание массива с n количеством элементов
    for i in range(n):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1
    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0
    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < n:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент - простое число)
            while j < n:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1
    # вывод простых чисел на экран (может быть реализован как угодно)
    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])

    del a
    return b[n1 - 2]


tic = time()
print(no_eratosthenes(1000000))
toc = time()
print(toc - tic)
tic = time()
print(sieve_eratosthenes(1000000))
toc = time()
print(toc - tic)

#  Вывод - при увеличеннии кол-ва выбитых элементов операция Эратосфена работает ,быстрее.
# Без Эратосфера (1000000,  15485857)
# 192.61816143989563
# Использование Эратосфена 15485857
# 33.78947186470032
